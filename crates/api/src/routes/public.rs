//! Public routes that don't require authentication
//!
//! These endpoints are accessible without a valid JWT token.
//! Used for public-facing features like enterprise sales inquiries.

use axum::{extract::State, Json};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;

use crate::{
    error::{ApiError, ApiResult},
    state::AppState,
};

// =============================================================================
// Request/Response Types
// =============================================================================

/// Company size options for enterprise inquiries
const VALID_COMPANY_SIZES: &[&str] = &[
    "1-10",
    "11-50",
    "51-200",
    "201-500",
    "500+",
];

#[derive(Debug, Deserialize)]
pub struct EnterpriseInquiryRequest {
    pub company_name: String,
    pub work_email: String,
    pub company_size: String,
    pub use_case: String,
}

#[derive(Debug, Serialize)]
pub struct EnterpriseInquiryResponse {
    pub success: bool,
    pub ticket_number: String,
    pub message: String,
}

// =============================================================================
// Database Row Types
// =============================================================================

#[derive(Debug, FromRow)]
struct TicketRow {
    id: Uuid,
    ticket_number: String,
}

// =============================================================================
// Validation Helpers
// =============================================================================

/// Validates an email address format
fn is_valid_email(email: &str) -> bool {
    // Basic email validation: contains @, has content before and after @
    let parts: Vec<&str> = email.split('@').collect();
    if parts.len() != 2 {
        return false;
    }
    let (local, domain) = (parts[0], parts[1]);
    !local.is_empty() && !domain.is_empty() && domain.contains('.')
}

/// Validates company size is one of the allowed options
fn is_valid_company_size(size: &str) -> bool {
    VALID_COMPANY_SIZES.contains(&size)
}

// =============================================================================
// Handlers
// =============================================================================

/// Submit an enterprise sales inquiry (no auth required)
///
/// Creates a support ticket with category 'enterprise_inquiry' that will be
/// handled by the sales team. The inquiry captures company information
/// and use case details.
pub async fn submit_enterprise_inquiry(
    State(state): State<AppState>,
    Json(req): Json<EnterpriseInquiryRequest>,
) -> ApiResult<Json<EnterpriseInquiryResponse>> {
    // Validate company name
    let company_name = req.company_name.trim();
    if company_name.len() < 2 {
        return Err(ApiError::BadRequest(
            "Company name must be at least 2 characters".into(),
        ));
    }
    if company_name.len() > 200 {
        return Err(ApiError::BadRequest(
            "Company name must be less than 200 characters".into(),
        ));
    }

    // Validate work email
    let work_email = req.work_email.trim().to_lowercase();
    if !is_valid_email(&work_email) {
        return Err(ApiError::BadRequest("Please enter a valid email address".into()));
    }

    // Validate company size
    if !is_valid_company_size(&req.company_size) {
        return Err(ApiError::BadRequest(
            "Please select a valid company size".into(),
        ));
    }

    // Validate use case
    let use_case = req.use_case.trim();
    if use_case.len() < 20 {
        return Err(ApiError::BadRequest(
            "Please provide more details about your use case (at least 20 characters)".into(),
        ));
    }
    if use_case.len() > 5000 {
        return Err(ApiError::BadRequest(
            "Use case description is too long (max 5000 characters)".into(),
        ));
    }

    // Format the ticket content with all the collected information
    let content = format!(
        "**Enterprise Inquiry**\n\n\
        **Company:** {}\n\
        **Contact Email:** {}\n\
        **Company Size:** {} employees\n\n\
        **Use Case:**\n{}",
        company_name, work_email, req.company_size, use_case
    );

    // Create the subject line
    let subject = format!("Enterprise Inquiry from {}", company_name);

    // Insert the support ticket (no user_id or organization_id since this is public)
    // ticket_number is auto-generated by database trigger
    // Store contact info so we can identify the exact person who submitted the inquiry
    let ticket: TicketRow = sqlx::query_as(
        r#"
        INSERT INTO support_tickets (
            organization_id,
            user_id,
            subject,
            category,
            priority,
            contact_name,
            contact_email,
            contact_company
        )
        VALUES (NULL, NULL, $1, 'enterprise_inquiry'::ticket_category, 'high'::ticket_priority, $2, $3, $4)
        RETURNING id, ticket_number
        "#,
    )
    .bind(&subject)
    .bind(company_name)
    .bind(&work_email)
    .bind(company_name)
    .fetch_one(&state.pool)
    .await?;

    // Insert the initial message with the formatted content
    sqlx::query(
        r#"
        INSERT INTO ticket_messages (ticket_id, sender_id, is_admin_reply, content)
        VALUES ($1, NULL, false, $2)
        "#,
    )
    .bind(ticket.id)
    .bind(&content)
    .execute(&state.pool)
    .await?;

    tracing::info!(
        ticket_id = %ticket.id,
        ticket_number = %ticket.ticket_number,
        company = %company_name,
        email = %work_email,
        "Enterprise inquiry submitted"
    );

    Ok(Json(EnterpriseInquiryResponse {
        success: true,
        ticket_number: ticket.ticket_number,
        message: "Thank you for your interest! Our enterprise team will contact you within 1 business day.".into(),
    }))
}
