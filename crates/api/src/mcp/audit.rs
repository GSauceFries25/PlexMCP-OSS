//! MCP Request Audit Logging
//!
//! Logs all MCP proxy requests to the mcp_request_log table for:
//! - Usage tracking and metered billing
//! - Security monitoring (rate limiting, quota enforcement)
//! - Performance analytics (latency tracking)
//! - SOC 2 compliance (access audit trail)
//!
//! This module provides async logging that doesn't block request processing.

use sqlx::PgPool;
use uuid::Uuid;

/// MCP Request Log Entry
///
/// Captures all relevant information about an MCP proxy request for audit logging.
#[derive(Debug, Clone)]
pub struct McpRequestLog {
    /// Unique identifier for this request (generated by handler)
    pub request_id: Uuid,

    /// User who made the request (from auth context)
    pub user_id: Option<Uuid>,

    /// Organization the user belongs to (for billing)
    pub organization_id: Option<Uuid>,

    /// Tenant ID for multi-tenant isolation tracking
    pub tenant_id: Option<Uuid>,

    /// Which MCP server handled the request (e.g., "github", "supabase", "filesystem")
    /// For aggregation requests (tools/list), this may be "all" or comma-separated list
    pub mcp_server_name: String,

    /// MCP method called (e.g., "tools/call", "resources/read", "tools/list")
    pub endpoint_path: String,

    /// HTTP method (typically "POST" for MCP JSON-RPC)
    pub http_method: String,

    /// HTTP status code (200, 400, 401, 429, 500, etc.)
    pub http_status_code: i32,

    /// Request body size in bytes
    pub request_size_bytes: Option<i32>,

    /// Response body size in bytes
    pub response_size_bytes: Option<i32>,

    /// Request latency in milliseconds
    pub latency_ms: Option<i32>,

    /// Number of tokens consumed (if applicable, for billing)
    pub tokens_used: Option<i32>,

    /// API key ID if request was authenticated via API key
    pub api_key_id: Option<Uuid>,

    /// Session ID if request was authenticated via session
    pub session_id: Option<Uuid>,

    /// Client IP address (for security monitoring)
    pub source_ip: Option<String>,

    /// User-Agent header
    pub user_agent: Option<String>,

    /// Error message if request failed
    pub error_message: Option<String>,

    /// Error code if request failed
    pub error_code: Option<String>,

    /// Whether this request hit rate limiting
    pub rate_limit_hit: bool,

    /// Whether this request exceeded usage quota
    pub quota_exceeded: bool,

    /// Additional metadata in JSONB format
    pub metadata: Option<serde_json::Value>,
}

impl Default for McpRequestLog {
    fn default() -> Self {
        Self {
            request_id: Uuid::new_v4(),
            user_id: None,
            organization_id: None,
            tenant_id: None,
            mcp_server_name: String::new(),
            endpoint_path: String::new(),
            http_method: "POST".to_string(),
            http_status_code: 200,
            request_size_bytes: None,
            response_size_bytes: None,
            latency_ms: None,
            tokens_used: None,
            api_key_id: None,
            session_id: None,
            source_ip: None,
            user_agent: None,
            error_message: None,
            error_code: None,
            rate_limit_hit: false,
            quota_exceeded: false,
            metadata: None,
        }
    }
}

/// Log an MCP request asynchronously
///
/// This function spawns a background task to log the request, ensuring that
/// logging doesn't block the response to the client.
///
/// # Arguments
///
/// * `pool` - Database connection pool
/// * `log` - Request log entry to persist
///
/// # Example
///
/// ```ignore
/// let log = McpRequestLog {
///     request_id: Uuid::new_v4(),
///     user_id: Some(user.id),
///     organization_id: Some(org.id),
///     mcp_server_name: "github".to_string(),
///     endpoint_path: "tools/call".to_string(),
///     http_method: "POST".to_string(),
///     http_status_code: 200,
///     latency_ms: Some(150),
///     ..Default::default()
/// };
///
/// log_mcp_request(pool.clone(), log);
/// ```
pub fn log_mcp_request(pool: PgPool, log: McpRequestLog) {
    // Spawn async task to log request (don't block response)
    tokio::spawn(async move {
        if let Err(e) = log_mcp_request_impl(&pool, log).await {
            tracing::error!("Failed to log MCP request: {}", e);
        }
    });
}

/// Internal implementation of MCP request logging
///
/// Performs the actual database INSERT operation. Called from `log_mcp_request`
/// in a spawned task.
async fn log_mcp_request_impl(pool: &PgPool, log: McpRequestLog) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        INSERT INTO mcp_request_log (
            request_id,
            user_id,
            organization_id,
            tenant_id,
            mcp_server_name,
            endpoint_path,
            http_method,
            http_status_code,
            request_size_bytes,
            response_size_bytes,
            latency_ms,
            tokens_used,
            api_key_id,
            session_id,
            source_ip,
            user_agent,
            error_message,
            error_code,
            rate_limit_hit,
            quota_exceeded,
            metadata,
            created_at
        )
        VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
            $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
            $21, NOW()
        )
        "#,
    )
    .bind(log.request_id)
    .bind(log.user_id)
    .bind(log.organization_id)
    .bind(log.tenant_id)
    .bind(&log.mcp_server_name)
    .bind(&log.endpoint_path)
    .bind(&log.http_method)
    .bind(log.http_status_code)
    .bind(log.request_size_bytes)
    .bind(log.response_size_bytes)
    .bind(log.latency_ms)
    .bind(log.tokens_used)
    .bind(log.api_key_id)
    .bind(log.session_id)
    .bind(log.source_ip)
    .bind(log.user_agent)
    .bind(log.error_message)
    .bind(log.error_code)
    .bind(log.rate_limit_hit)
    .bind(log.quota_exceeded)
    .bind(log.metadata)
    .execute(pool)
    .await?;

    Ok(())
}

/// Update an MCP request log entry with token usage (for async completion)
///
/// Some MCP operations may not know token usage until after response processing.
/// This function allows updating an existing log entry with token information.
///
/// # Arguments
///
/// * `pool` - Database connection pool
/// * `request_id` - ID of the request to update
/// * `tokens_used` - Number of tokens consumed
pub async fn update_mcp_request_tokens(
    pool: &PgPool,
    request_id: Uuid,
    tokens_used: i32,
) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        UPDATE mcp_request_log
        SET tokens_used = $1,
            processed_at = NOW()
        WHERE request_id = $2
        "#,
    )
    .bind(tokens_used)
    .bind(request_id)
    .execute(pool)
    .await?;

    Ok(())
}

/// Update an MCP request log entry with response size and latency
///
/// Allows updating request metadata after response is processed.
///
/// # Arguments
///
/// * `pool` - Database connection pool
/// * `request_id` - ID of the request to update
/// * `response_size_bytes` - Response size in bytes
/// * `latency_ms` - Request latency in milliseconds
pub async fn update_mcp_request_metrics(
    pool: &PgPool,
    request_id: Uuid,
    response_size_bytes: i32,
    latency_ms: i32,
) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        UPDATE mcp_request_log
        SET response_size_bytes = $1,
            latency_ms = $2,
            processed_at = NOW()
        WHERE request_id = $3
        "#,
    )
    .bind(response_size_bytes)
    .bind(latency_ms)
    .bind(request_id)
    .execute(pool)
    .await?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mcp_request_log_default() {
        let log = McpRequestLog::default();
        assert_eq!(log.http_method, "POST");
        assert_eq!(log.http_status_code, 200);
        assert!(!log.rate_limit_hit);
        assert!(!log.quota_exceeded);
    }

    #[test]
    fn test_mcp_request_log_builder() {
        let request_id = Uuid::new_v4();
        let user_id = Uuid::new_v4();

        let log = McpRequestLog {
            request_id,
            user_id: Some(user_id),
            mcp_server_name: "github".to_string(),
            endpoint_path: "tools/call".to_string(),
            http_status_code: 200,
            latency_ms: Some(150),
            ..Default::default()
        };

        assert_eq!(log.request_id, request_id);
        assert_eq!(log.user_id, Some(user_id));
        assert_eq!(log.mcp_server_name, "github");
        assert_eq!(log.endpoint_path, "tools/call");
        assert_eq!(log.latency_ms, Some(150));
    }
}
