-- OAuth State Token Storage for CSRF Protection (SOC 2 CC6.1)
--
-- This table stores OAuth state tokens to prevent CSRF attacks on the OAuth flow.
-- The state parameter is generated by the backend before redirecting to OAuth provider,
-- and validated when the OAuth callback is received.

CREATE TABLE IF NOT EXISTS oauth_state_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    state_token TEXT UNIQUE NOT NULL,
    code_verifier TEXT NOT NULL,
    redirect_url TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '10 minutes',
    used_at TIMESTAMPTZ
);

-- Index for efficient expiry cleanup
CREATE INDEX IF NOT EXISTS idx_oauth_state_expires ON oauth_state_tokens(expires_at);

-- Index for fast state token lookup during validation
CREATE INDEX IF NOT EXISTS idx_oauth_state_token ON oauth_state_tokens(state_token);

-- Enable and FORCE Row Level Security (SOC 2 CC6.1)
ALTER TABLE oauth_state_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE oauth_state_tokens FORCE ROW LEVEL SECURITY;

-- Only service role can access (backend API only - no direct user access)
-- This table is only accessed by the backend during OAuth flow
CREATE POLICY oauth_state_service_only ON oauth_state_tokens
    FOR ALL TO service_role
    USING (true)
    WITH CHECK (true);

-- Add cleanup job for expired tokens (runs every hour)
-- This prevents table bloat from abandoned OAuth flows
-- Only schedule if pg_cron is available (not in test environments)
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
        PERFORM cron.schedule(
            'cleanup-oauth-state-tokens',
            '0 * * * *',  -- Every hour at minute 0
            'DELETE FROM oauth_state_tokens WHERE expires_at < NOW()'
        );
    ELSE
        RAISE NOTICE 'pg_cron not available - skipping cleanup job scheduling (this is expected in test environments)';
    END IF;
END $$;
